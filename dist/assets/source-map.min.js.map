{"version":3,"sources":["source-map.js"],"names":["define","moduleName","deps","payload","TypeError","arguments","length","modules","Error","Domain","this","_currentModule","normalize","path","bits","split","i","splice","join","a","b","trim","test","replace","dirname","pop","prototype","require","callback","Array","isArray","params","map","dep","lookup","apply","module","exports","previousModule","bind","id","uri","globalDomain","SourceMapGenerator","aArgs","_file","util","getArg","_sourceRoot","_skipValidation","_sources","ArraySet","_names","_mappings","MappingList","_sourcesContents","base64VLQ","_version","fromSourceMap","aSourceMapConsumer","sourceRoot","generator","file","eachMapping","mapping","newMapping","generated","line","generatedLine","column","generatedColumn","source","relative","original","originalLine","originalColumn","name","addMapping","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","_validateMapping","has","add","aSourceFile","aSourceContent","toSetString","Object","keys","applySourceMap","aSourceMapPath","newSources","newNames","unsortedForEach","originalPositionFor","aGenerated","aOriginal","aSource","aName","JSON","stringify","_serializeMappings","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","result","mappings","toArray","len","compareByGeneratedPositions","encode","indexOf","_generateSourcesContent","aSources","aSourceRoot","key","hasOwnProperty","call","toJSON","version","names","sourcesContent","toString","toVLQSigned","aValue","fromVLQSigned","isNegative","shifted","base64","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","digit","encoded","vlq","decode","aStr","aOutParam","continuation","strLen","shift","charAt","value","rest","slice","charToIntMap","intToCharMap","ch","index","aNumber","aChar","aDefaultValue","urlParse","aUrl","match","urlRegexp","scheme","auth","host","port","urlGenerate","aParsedUrl","url","aPath","part","isAbsolute","parts","up","aRoot","aPathUrl","aRootUrl","dataUrlRegexp","joined","substr","fromSetString","strcmp","aStr1","aStr2","s1","s2","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","onlyCompareGenerated","_array","_set","fromArray","aArray","aAllowDuplicates","set","isDuplicate","idx","push","at","aIdx","generatedPositionAfter","lineA","lineB","columnA","columnB","_sorted","_last","aCallback","aThisArg","aMapping","sort","SourceMapConsumer","aSourceMap","sourceMap","parse","sections","indexedSourceMapConsumer","IndexedSourceMapConsumer","basicSourceMapConsumer","BasicSourceMapConsumer","__generatedMappings","defineProperty","get","__originalMappings","_parseMappings","_nextCharIsMappingSeparator","c","GENERATED_ORDER","ORIGINAL_ORDER","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","aContext","aOrder","context","order","_generatedMappings","_originalMappings","allGeneratedPositionsFor","needle","_findMapping","lastColumn","lastOffset","_sections","s","offset","offsetLine","offsetColumn","generatedOffset","consumer","binarySearch","create","constructor","j","sectionIndex","search","section","nullOnMissing","generatedPositionFor","generatedPosition","ret","sectionMappings","adjustedMapping","recursiveSearch","aLow","aHigh","aNeedle","aHaystack","aCompare","aBias","mid","Math","floor","smc","str","temp","aMappings","aLineName","aColumnName","aComparator","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","fileUriAbsPath","SourceNode","aLine","aColumn","aChunks","children","sourceContents","isSourceNode","REGEX_NEWLINE","NEWLINE_CODE","fromStringWithSourceMap","aGeneratedCode","aRelativePath","addMappingWithCode","code","undefined","node","remainingLines","shiftNextLine","lineContents","newLine","lastGeneratedLine","lastMapping","nextLine","aChunk","chunk","prepend","unshift","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","walkSourceContents","toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","charCodeAt","sourceContent"],"mappings":"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","file":"source-map.min.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * Define a module along with a payload.\n * @param {string} moduleName Name for the payload\n * @param {ignored} deps Ignored. For compatibility with CommonJS AMD Spec\n * @param {function} payload Function with (require, exports, module) params\n */\nfunction define(moduleName, deps, payload) {\n  if (typeof moduleName != \"string\") {\n    throw new TypeError('Expected string, got: ' + moduleName);\n  }\n\n  if (arguments.length == 2) {\n    payload = deps;\n  }\n\n  if (moduleName in define.modules) {\n    throw new Error(\"Module already defined: \" + moduleName);\n  }\n  define.modules[moduleName] = payload;\n};\n\n/**\n * The global store of un-instantiated modules\n */\ndefine.modules = {};\n\n\n/**\n * We invoke require() in the context of a Domain so we can have multiple\n * sets of modules running separate from each other.\n * This contrasts with JSMs which are singletons, Domains allows us to\n * optionally load a CommonJS module twice with separate data each time.\n * Perhaps you want 2 command lines with a different set of commands in each,\n * for example.\n */\nfunction Domain() {\n  this.modules = {};\n  this._currentModule = null;\n}\n\n(function () {\n\n  /**\n   * Lookup module names and resolve them by calling the definition function if\n   * needed.\n   * There are 2 ways to call this, either with an array of dependencies and a\n   * callback to call when the dependencies are found (which can happen\n   * asynchronously in an in-page context) or with a single string an no callback\n   * where the dependency is resolved synchronously and returned.\n   * The API is designed to be compatible with the CommonJS AMD spec and\n   * RequireJS.\n   * @param {string[]|string} deps A name, or names for the payload\n   * @param {function|undefined} callback Function to call when the dependencies\n   * are resolved\n   * @return {undefined|object} The module required or undefined for\n   * array/callback method\n   */\n  Domain.prototype.require = function(deps, callback) {\n    if (Array.isArray(deps)) {\n      var params = deps.map(function(dep) {\n        return this.lookup(dep);\n      }, this);\n      if (callback) {\n        callback.apply(null, params);\n      }\n      return undefined;\n    }\n    else {\n      return this.lookup(deps);\n    }\n  };\n\n  function normalize(path) {\n    var bits = path.split('/');\n    var i = 1;\n    while (i < bits.length) {\n      if (bits[i] === '..') {\n        bits.splice(i-1, 1);\n      } else if (bits[i] === '.') {\n        bits.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n    return bits.join('/');\n  }\n\n  function join(a, b) {\n    a = a.trim();\n    b = b.trim();\n    if (/^\\//.test(b)) {\n      return b;\n    } else {\n      return a.replace(/\\/*$/, '/') + b;\n    }\n  }\n\n  function dirname(path) {\n    var bits = path.split('/');\n    bits.pop();\n    return bits.join('/');\n  }\n\n  /**\n   * Lookup module names and resolve them by calling the definition function if\n   * needed.\n   * @param {string} moduleName A name for the payload to lookup\n   * @return {object} The module specified by aModuleName or null if not found.\n   */\n  Domain.prototype.lookup = function(moduleName) {\n    if (/^\\./.test(moduleName)) {\n      moduleName = normalize(join(dirname(this._currentModule), moduleName));\n    }\n\n    if (moduleName in this.modules) {\n      var module = this.modules[moduleName];\n      return module;\n    }\n\n    if (!(moduleName in define.modules)) {\n      throw new Error(\"Module not defined: \" + moduleName);\n    }\n\n    var module = define.modules[moduleName];\n\n    if (typeof module == \"function\") {\n      var exports = {};\n      var previousModule = this._currentModule;\n      this._currentModule = moduleName;\n      module(this.require.bind(this), exports, { id: moduleName, uri: \"\" });\n      this._currentModule = previousModule;\n      module = exports;\n    }\n\n    // cache the resulting module object for next time\n    this.modules[moduleName] = module;\n\n    return module;\n  };\n\n}());\n\ndefine.Domain = Domain;\ndefine.globalDomain = new Domain();\nvar require = define.globalDomain.require.bind(define.globalDomain);\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/source-map-generator', ['require', 'exports', 'module' ,  'source-map/base64-vlq', 'source-map/util', 'source-map/array-set', 'source-map/mapping-list'], function(require, exports, module) {\n\n  var base64VLQ = require('./base64-vlq');\n  var util = require('./util');\n  var ArraySet = require('./array-set').ArraySet;\n  var MappingList = require('./mapping-list').MappingList;\n\n  /**\n   * An instance of the SourceMapGenerator represents a source map which is\n   * being built incrementally. You may pass an object with the following\n   * properties:\n   *\n   *   - file: The filename of the generated source.\n   *   - sourceRoot: A root for all relative URLs in this source map.\n   */\n  function SourceMapGenerator(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, 'file', null);\n    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  SourceMapGenerator.prototype._version = 3;\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  SourceMapGenerator.fromSourceMap =\n    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n      var sourceRoot = aSourceMapConsumer.sourceRoot;\n      var generator = new SourceMapGenerator({\n        file: aSourceMapConsumer.file,\n        sourceRoot: sourceRoot\n      });\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        var newMapping = {\n          generated: {\n            line: mapping.generatedLine,\n            column: mapping.generatedColumn\n          }\n        };\n\n        if (mapping.source != null) {\n          newMapping.source = mapping.source;\n          if (sourceRoot != null) {\n            newMapping.source = util.relative(sourceRoot, newMapping.source);\n          }\n\n          newMapping.original = {\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          };\n\n          if (mapping.name != null) {\n            newMapping.name = mapping.name;\n          }\n        }\n\n        generator.addMapping(newMapping);\n      });\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          generator.setSourceContent(sourceFile, content);\n        }\n      });\n      return generator;\n    };\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  SourceMapGenerator.prototype.addMapping =\n    function SourceMapGenerator_addMapping(aArgs) {\n      var generated = util.getArg(aArgs, 'generated');\n      var original = util.getArg(aArgs, 'original', null);\n      var source = util.getArg(aArgs, 'source', null);\n      var name = util.getArg(aArgs, 'name', null);\n\n      if (!this._skipValidation) {\n        this._validateMapping(generated, original, source, name);\n      }\n\n      if (source != null && !this._sources.has(source)) {\n        this._sources.add(source);\n      }\n\n      if (name != null && !this._names.has(name)) {\n        this._names.add(name);\n      }\n\n      this._mappings.add({\n        generatedLine: generated.line,\n        generatedColumn: generated.column,\n        originalLine: original != null && original.line,\n        originalColumn: original != null && original.column,\n        source: source,\n        name: name\n      });\n    };\n\n  /**\n   * Set the source content for a source file.\n   */\n  SourceMapGenerator.prototype.setSourceContent =\n    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n      var source = aSourceFile;\n      if (this._sourceRoot != null) {\n        source = util.relative(this._sourceRoot, source);\n      }\n\n      if (aSourceContent != null) {\n        // Add the source content to the _sourcesContents map.\n        // Create a new _sourcesContents map if the property is null.\n        if (!this._sourcesContents) {\n          this._sourcesContents = {};\n        }\n        this._sourcesContents[util.toSetString(source)] = aSourceContent;\n      } else if (this._sourcesContents) {\n        // Remove the source file from the _sourcesContents map.\n        // If the _sourcesContents map is empty, set the property to null.\n        delete this._sourcesContents[util.toSetString(source)];\n        if (Object.keys(this._sourcesContents).length === 0) {\n          this._sourcesContents = null;\n        }\n      }\n    };\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  SourceMapGenerator.prototype.applySourceMap =\n    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n      var sourceFile = aSourceFile;\n      // If aSourceFile is omitted, we will use the file property of the SourceMap\n      if (aSourceFile == null) {\n        if (aSourceMapConsumer.file == null) {\n          throw new Error(\n            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n            'or the source map\\'s \"file\" property. Both were omitted.'\n          );\n        }\n        sourceFile = aSourceMapConsumer.file;\n      }\n      var sourceRoot = this._sourceRoot;\n      // Make \"sourceFile\" relative if an absolute Url is passed.\n      if (sourceRoot != null) {\n        sourceFile = util.relative(sourceRoot, sourceFile);\n      }\n      // Applying the SourceMap can add and remove items from the sources and\n      // the names array.\n      var newSources = new ArraySet();\n      var newNames = new ArraySet();\n\n      // Find mappings for the \"sourceFile\"\n      this._mappings.unsortedForEach(function (mapping) {\n        if (mapping.source === sourceFile && mapping.originalLine != null) {\n          // Check if it can be mapped by the source map, then update the mapping.\n          var original = aSourceMapConsumer.originalPositionFor({\n            line: mapping.originalLine,\n            column: mapping.originalColumn\n          });\n          if (original.source != null) {\n            // Copy mapping\n            mapping.source = original.source;\n            if (aSourceMapPath != null) {\n              mapping.source = util.join(aSourceMapPath, mapping.source)\n            }\n            if (sourceRoot != null) {\n              mapping.source = util.relative(sourceRoot, mapping.source);\n            }\n            mapping.originalLine = original.line;\n            mapping.originalColumn = original.column;\n            if (original.name != null) {\n              mapping.name = original.name;\n            }\n          }\n        }\n\n        var source = mapping.source;\n        if (source != null && !newSources.has(source)) {\n          newSources.add(source);\n        }\n\n        var name = mapping.name;\n        if (name != null && !newNames.has(name)) {\n          newNames.add(name);\n        }\n\n      }, this);\n      this._sources = newSources;\n      this._names = newNames;\n\n      // Copy sourcesContents of applied map.\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aSourceMapPath != null) {\n            sourceFile = util.join(aSourceMapPath, sourceFile);\n          }\n          if (sourceRoot != null) {\n            sourceFile = util.relative(sourceRoot, sourceFile);\n          }\n          this.setSourceContent(sourceFile, content);\n        }\n      }, this);\n    };\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  SourceMapGenerator.prototype._validateMapping =\n    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                                aName) {\n      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n          && aGenerated.line > 0 && aGenerated.column >= 0\n          && !aOriginal && !aSource && !aName) {\n        // Case 1.\n        return;\n      }\n      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n               && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n               && aGenerated.line > 0 && aGenerated.column >= 0\n               && aOriginal.line > 0 && aOriginal.column >= 0\n               && aSource) {\n        // Cases 2 and 3.\n        return;\n      }\n      else {\n        throw new Error('Invalid mapping: ' + JSON.stringify({\n          generated: aGenerated,\n          source: aSource,\n          original: aOriginal,\n          name: aName\n        }));\n      }\n    };\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  SourceMapGenerator.prototype._serializeMappings =\n    function SourceMapGenerator_serializeMappings() {\n      var previousGeneratedColumn = 0;\n      var previousGeneratedLine = 1;\n      var previousOriginalColumn = 0;\n      var previousOriginalLine = 0;\n      var previousName = 0;\n      var previousSource = 0;\n      var result = '';\n      var mapping;\n\n      var mappings = this._mappings.toArray();\n\n      for (var i = 0, len = mappings.length; i < len; i++) {\n        mapping = mappings[i];\n\n        if (mapping.generatedLine !== previousGeneratedLine) {\n          previousGeneratedColumn = 0;\n          while (mapping.generatedLine !== previousGeneratedLine) {\n            result += ';';\n            previousGeneratedLine++;\n          }\n        }\n        else {\n          if (i > 0) {\n            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {\n              continue;\n            }\n            result += ',';\n          }\n        }\n\n        result += base64VLQ.encode(mapping.generatedColumn\n                                   - previousGeneratedColumn);\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (mapping.source != null) {\n          result += base64VLQ.encode(this._sources.indexOf(mapping.source)\n                                     - previousSource);\n          previousSource = this._sources.indexOf(mapping.source);\n\n          // lines are stored 0-based in SourceMap spec version 3\n          result += base64VLQ.encode(mapping.originalLine - 1\n                                     - previousOriginalLine);\n          previousOriginalLine = mapping.originalLine - 1;\n\n          result += base64VLQ.encode(mapping.originalColumn\n                                     - previousOriginalColumn);\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (mapping.name != null) {\n            result += base64VLQ.encode(this._names.indexOf(mapping.name)\n                                       - previousName);\n            previousName = this._names.indexOf(mapping.name);\n          }\n        }\n      }\n\n      return result;\n    };\n\n  SourceMapGenerator.prototype._generateSourcesContent =\n    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n      return aSources.map(function (source) {\n        if (!this._sourcesContents) {\n          return null;\n        }\n        if (aSourceRoot != null) {\n          source = util.relative(aSourceRoot, source);\n        }\n        var key = util.toSetString(source);\n        return Object.prototype.hasOwnProperty.call(this._sourcesContents,\n                                                    key)\n          ? this._sourcesContents[key]\n          : null;\n      }, this);\n    };\n\n  /**\n   * Externalize the source map.\n   */\n  SourceMapGenerator.prototype.toJSON =\n    function SourceMapGenerator_toJSON() {\n      var map = {\n        version: this._version,\n        sources: this._sources.toArray(),\n        names: this._names.toArray(),\n        mappings: this._serializeMappings()\n      };\n      if (this._file != null) {\n        map.file = this._file;\n      }\n      if (this._sourceRoot != null) {\n        map.sourceRoot = this._sourceRoot;\n      }\n      if (this._sourcesContents) {\n        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n      }\n\n      return map;\n    };\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  SourceMapGenerator.prototype.toString =\n    function SourceMapGenerator_toString() {\n      return JSON.stringify(this.toJSON());\n    };\n\n  exports.SourceMapGenerator = SourceMapGenerator;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\ndefine('source-map/base64-vlq', ['require', 'exports', 'module' ,  'source-map/base64'], function(require, exports, module) {\n\n  var base64 = require('./base64');\n\n  // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n  // length quantities we use in the source map spec, the first bit is the sign,\n  // the next four bits are the actual value, and the 6th bit is the\n  // continuation bit. The continuation bit tells us whether there are more\n  // digits in this value following this digit.\n  //\n  //   Continuation\n  //   |    Sign\n  //   |    |\n  //   V    V\n  //   101011\n\n  var VLQ_BASE_SHIFT = 5;\n\n  // binary: 100000\n  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n  // binary: 011111\n  var VLQ_BASE_MASK = VLQ_BASE - 1;\n\n  // binary: 100000\n  var VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n  /**\n   * Converts from a two-complement value to a value where the sign bit is\n   * placed in the least significant bit.  For example, as decimals:\n   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n   */\n  function toVLQSigned(aValue) {\n    return aValue < 0\n      ? ((-aValue) << 1) + 1\n      : (aValue << 1) + 0;\n  }\n\n  /**\n   * Converts to a two-complement value from a value where the sign bit is\n   * placed in the least significant bit.  For example, as decimals:\n   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n   */\n  function fromVLQSigned(aValue) {\n    var isNegative = (aValue & 1) === 1;\n    var shifted = aValue >> 1;\n    return isNegative\n      ? -shifted\n      : shifted;\n  }\n\n  /**\n   * Returns the base 64 VLQ encoded value.\n   */\n  exports.encode = function base64VLQ_encode(aValue) {\n    var encoded = \"\";\n    var digit;\n\n    var vlq = toVLQSigned(aValue);\n\n    do {\n      digit = vlq & VLQ_BASE_MASK;\n      vlq >>>= VLQ_BASE_SHIFT;\n      if (vlq > 0) {\n        // There are still more digits in this value, so we must make sure the\n        // continuation bit is marked.\n        digit |= VLQ_CONTINUATION_BIT;\n      }\n      encoded += base64.encode(digit);\n    } while (vlq > 0);\n\n    return encoded;\n  };\n\n  /**\n   * Decodes the next base 64 VLQ value from the given string and returns the\n   * value and the rest of the string via the out parameter.\n   */\n  exports.decode = function base64VLQ_decode(aStr, aOutParam) {\n    var i = 0;\n    var strLen = aStr.length;\n    var result = 0;\n    var shift = 0;\n    var continuation, digit;\n\n    do {\n      if (i >= strLen) {\n        throw new Error(\"Expected more digits in base 64 VLQ value.\");\n      }\n      digit = base64.decode(aStr.charAt(i++));\n      continuation = !!(digit & VLQ_CONTINUATION_BIT);\n      digit &= VLQ_BASE_MASK;\n      result = result + (digit << shift);\n      shift += VLQ_BASE_SHIFT;\n    } while (continuation);\n\n    aOutParam.value = fromVLQSigned(result);\n    aOutParam.rest = aStr.slice(i);\n  };\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/base64', ['require', 'exports', 'module' , ], function(require, exports, module) {\n\n  var charToIntMap = {};\n  var intToCharMap = {};\n\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    .split('')\n    .forEach(function (ch, index) {\n      charToIntMap[ch] = index;\n      intToCharMap[index] = ch;\n    });\n\n  /**\n   * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n   */\n  exports.encode = function base64_encode(aNumber) {\n    if (aNumber in intToCharMap) {\n      return intToCharMap[aNumber];\n    }\n    throw new TypeError(\"Must be between 0 and 63: \" + aNumber);\n  };\n\n  /**\n   * Decode a single base 64 digit to an integer.\n   */\n  exports.decode = function base64_decode(aChar) {\n    if (aChar in charToIntMap) {\n      return charToIntMap[aChar];\n    }\n    throw new TypeError(\"Not a valid base 64 digit: \" + aChar);\n  };\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/util', ['require', 'exports', 'module' , ], function(require, exports, module) {\n\n  /**\n   * This is a helper function for getting values from parameter/options\n   * objects.\n   *\n   * @param args The object we are extracting values from\n   * @param name The name of the property we are getting.\n   * @param defaultValue An optional value to return if the property is missing\n   * from the object. If this is not specified and the property is missing, an\n   * error will be thrown.\n   */\n  function getArg(aArgs, aName, aDefaultValue) {\n    if (aName in aArgs) {\n      return aArgs[aName];\n    } else if (arguments.length === 3) {\n      return aDefaultValue;\n    } else {\n      throw new Error('\"' + aName + '\" is a required argument.');\n    }\n  }\n  exports.getArg = getArg;\n\n  var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n  var dataUrlRegexp = /^data:.+\\,.+$/;\n\n  function urlParse(aUrl) {\n    var match = aUrl.match(urlRegexp);\n    if (!match) {\n      return null;\n    }\n    return {\n      scheme: match[1],\n      auth: match[2],\n      host: match[3],\n      port: match[4],\n      path: match[5]\n    };\n  }\n  exports.urlParse = urlParse;\n\n  function urlGenerate(aParsedUrl) {\n    var url = '';\n    if (aParsedUrl.scheme) {\n      url += aParsedUrl.scheme + ':';\n    }\n    url += '//';\n    if (aParsedUrl.auth) {\n      url += aParsedUrl.auth + '@';\n    }\n    if (aParsedUrl.host) {\n      url += aParsedUrl.host;\n    }\n    if (aParsedUrl.port) {\n      url += \":\" + aParsedUrl.port\n    }\n    if (aParsedUrl.path) {\n      url += aParsedUrl.path;\n    }\n    return url;\n  }\n  exports.urlGenerate = urlGenerate;\n\n  /**\n   * Normalizes a path, or the path portion of a URL:\n   *\n   * - Replaces consequtive slashes with one slash.\n   * - Removes unnecessary '.' parts.\n   * - Removes unnecessary '<dir>/..' parts.\n   *\n   * Based on code in the Node.js 'path' core module.\n   *\n   * @param aPath The path or url to normalize.\n   */\n  function normalize(aPath) {\n    var path = aPath;\n    var url = urlParse(aPath);\n    if (url) {\n      if (!url.path) {\n        return aPath;\n      }\n      path = url.path;\n    }\n    var isAbsolute = (path.charAt(0) === '/');\n\n    var parts = path.split(/\\/+/);\n    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n      part = parts[i];\n      if (part === '.') {\n        parts.splice(i, 1);\n      } else if (part === '..') {\n        up++;\n      } else if (up > 0) {\n        if (part === '') {\n          // The first part is blank if the path is absolute. Trying to go\n          // above the root is a no-op. Therefore we can remove all '..' parts\n          // directly after the root.\n          parts.splice(i + 1, up);\n          up = 0;\n        } else {\n          parts.splice(i, 2);\n          up--;\n        }\n      }\n    }\n    path = parts.join('/');\n\n    if (path === '') {\n      path = isAbsolute ? '/' : '.';\n    }\n\n    if (url) {\n      url.path = path;\n      return urlGenerate(url);\n    }\n    return path;\n  }\n  exports.normalize = normalize;\n\n  /**\n   * Joins two paths/URLs.\n   *\n   * @param aRoot The root path or URL.\n   * @param aPath The path or URL to be joined with the root.\n   *\n   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n   *   first.\n   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n   *   is updated with the result and aRoot is returned. Otherwise the result\n   *   is returned.\n   *   - If aPath is absolute, the result is aPath.\n   *   - Otherwise the two paths are joined with a slash.\n   * - Joining for example 'http://' and 'www.example.com' is also supported.\n   */\n  function join(aRoot, aPath) {\n    if (aRoot === \"\") {\n      aRoot = \".\";\n    }\n    if (aPath === \"\") {\n      aPath = \".\";\n    }\n    var aPathUrl = urlParse(aPath);\n    var aRootUrl = urlParse(aRoot);\n    if (aRootUrl) {\n      aRoot = aRootUrl.path || '/';\n    }\n\n    // `join(foo, '//www.example.org')`\n    if (aPathUrl && !aPathUrl.scheme) {\n      if (aRootUrl) {\n        aPathUrl.scheme = aRootUrl.scheme;\n      }\n      return urlGenerate(aPathUrl);\n    }\n\n    if (aPathUrl || aPath.match(dataUrlRegexp)) {\n      return aPath;\n    }\n\n    // `join('http://', 'www.example.com')`\n    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n      aRootUrl.host = aPath;\n      return urlGenerate(aRootUrl);\n    }\n\n    var joined = aPath.charAt(0) === '/'\n      ? aPath\n      : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n    if (aRootUrl) {\n      aRootUrl.path = joined;\n      return urlGenerate(aRootUrl);\n    }\n    return joined;\n  }\n  exports.join = join;\n\n  /**\n   * Make a path relative to a URL or another path.\n   *\n   * @param aRoot The root path or URL.\n   * @param aPath The path or URL to be made relative to aRoot.\n   */\n  function relative(aRoot, aPath) {\n    if (aRoot === \"\") {\n      aRoot = \".\";\n    }\n\n    aRoot = aRoot.replace(/\\/$/, '');\n\n    // XXX: It is possible to remove this block, and the tests still pass!\n    var url = urlParse(aRoot);\n    if (aPath.charAt(0) == \"/\" && url && url.path == \"/\") {\n      return aPath.slice(1);\n    }\n\n    return aPath.indexOf(aRoot + '/') === 0\n      ? aPath.substr(aRoot.length + 1)\n      : aPath;\n  }\n  exports.relative = relative;\n\n  /**\n   * Because behavior goes wacky when you set `__proto__` on objects, we\n   * have to prefix all the strings in our set with an arbitrary character.\n   *\n   * See https://github.com/mozilla/source-map/pull/31 and\n   * https://github.com/mozilla/source-map/issues/30\n   *\n   * @param String aStr\n   */\n  function toSetString(aStr) {\n    return '$' + aStr;\n  }\n  exports.toSetString = toSetString;\n\n  function fromSetString(aStr) {\n    return aStr.substr(1);\n  }\n  exports.fromSetString = fromSetString;\n\n  function strcmp(aStr1, aStr2) {\n    var s1 = aStr1 || \"\";\n    var s2 = aStr2 || \"\";\n    return (s1 > s2) - (s1 < s2);\n  }\n\n  /**\n   * Comparator between two mappings where the original positions are compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same original source/line/column, but different generated\n   * line and column the same. Useful when searching for a mapping with a\n   * stubbed out mapping.\n   */\n  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n    var cmp;\n\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp || onlyCompareOriginal) {\n      return cmp;\n    }\n\n    cmp = strcmp(mappingA.name, mappingB.name);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    return mappingA.generatedColumn - mappingB.generatedColumn;\n  };\n  exports.compareByOriginalPositions = compareByOriginalPositions;\n\n  /**\n   * Comparator between two mappings where the generated positions are\n   * compared.\n   *\n   * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n   * mappings with the same generated line and column, but different\n   * source/name/original line and column the same. Useful when searching for a\n   * mapping with a stubbed out mapping.\n   */\n  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {\n    var cmp;\n\n    cmp = mappingA.generatedLine - mappingB.generatedLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n    if (cmp || onlyCompareGenerated) {\n      return cmp;\n    }\n\n    cmp = strcmp(mappingA.source, mappingB.source);\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalLine - mappingB.originalLine;\n    if (cmp) {\n      return cmp;\n    }\n\n    cmp = mappingA.originalColumn - mappingB.originalColumn;\n    if (cmp) {\n      return cmp;\n    }\n\n    return strcmp(mappingA.name, mappingB.name);\n  };\n  exports.compareByGeneratedPositions = compareByGeneratedPositions;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/array-set', ['require', 'exports', 'module' ,  'source-map/util'], function(require, exports, module) {\n\n  var util = require('./util');\n\n  /**\n   * A data structure which is a combination of an array and a set. Adding a new\n   * member is O(1), testing for membership is O(1), and finding the index of an\n   * element is O(1). Removing elements from the set is not supported. Only\n   * strings are supported for membership.\n   */\n  function ArraySet() {\n    this._array = [];\n    this._set = {};\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n    var set = new ArraySet();\n    for (var i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  };\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n    var isDuplicate = this.has(aStr);\n    var idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set[util.toSetString(aStr)] = idx;\n    }\n  };\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.has = function ArraySet_has(aStr) {\n    return Object.prototype.hasOwnProperty.call(this._set,\n                                                util.toSetString(aStr));\n  };\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n    if (this.has(aStr)) {\n      return this._set[util.toSetString(aStr)];\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  };\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  ArraySet.prototype.at = function ArraySet_at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error('No element indexed by ' + aIdx);\n  };\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  ArraySet.prototype.toArray = function ArraySet_toArray() {\n    return this._array.slice();\n  };\n\n  exports.ArraySet = ArraySet;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/mapping-list', ['require', 'exports', 'module' ,  'source-map/util'], function(require, exports, module) {\n\n  var util = require('./util');\n\n  /**\n   * Determine whether mappingB is after mappingA with respect to generated\n   * position.\n   */\n  function generatedPositionAfter(mappingA, mappingB) {\n    // Optimized for most common case\n    var lineA = mappingA.generatedLine;\n    var lineB = mappingB.generatedLine;\n    var columnA = mappingA.generatedColumn;\n    var columnB = mappingB.generatedColumn;\n    return lineB > lineA || lineB == lineA && columnB >= columnA ||\n           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;\n  }\n\n  /**\n   * A data structure to provide a sorted view of accumulated mappings in a\n   * performance conscious manner. It trades a neglibable overhead in general\n   * case for a large speedup in case of mappings being added in order.\n   */\n  function MappingList() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {generatedLine: -1, generatedColumn: 0};\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  MappingList.prototype.unsortedForEach =\n    function MappingList_forEach(aCallback, aThisArg) {\n      this._array.forEach(aCallback, aThisArg);\n    };\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  MappingList.prototype.add = function MappingList_add(aMapping) {\n    var mapping;\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  };\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  MappingList.prototype.toArray = function MappingList_toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositions);\n      this._sorted = true;\n    }\n    return this._array;\n  };\n\n  exports.MappingList = MappingList;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/source-map-consumer', ['require', 'exports', 'module' ,  'source-map/util', 'source-map/indexed-source-map-consumer', 'source-map/basic-source-map-consumer'], function(require, exports, module) {\n\n  var util = require('./util');\n\n  function SourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    // We do late requires because the subclasses require() this file.\n    if (sourceMap.sections != null) {\n      var indexedSourceMapConsumer = require('./indexed-source-map-consumer');\n      return new indexedSourceMapConsumer.IndexedSourceMapConsumer(sourceMap);\n    } else {\n      var basicSourceMapConsumer = require('./basic-source-map-consumer');\n      return new basicSourceMapConsumer.BasicSourceMapConsumer(sourceMap);\n    }\n  }\n\n  SourceMapConsumer.fromSourceMap = function(aSourceMap) {\n    var basicSourceMapConsumer = require('./basic-source-map-consumer');\n    return basicSourceMapConsumer.BasicSourceMapConsumer\n            .fromSourceMap(aSourceMap);\n  }\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  SourceMapConsumer.prototype._version = 3;\n\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n\n  SourceMapConsumer.prototype.__generatedMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n    get: function () {\n      if (!this.__generatedMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__generatedMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype.__originalMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n    get: function () {\n      if (!this.__originalMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__originalMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype._nextCharIsMappingSeparator =\n    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {\n      var c = aStr.charAt(0);\n      return c === \";\" || c === \",\";\n    };\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  SourceMapConsumer.prototype._parseMappings =\n    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      throw new Error(\"Subclasses must implement _parseMappings\");\n    };\n\n  SourceMapConsumer.GENERATED_ORDER = 1;\n  SourceMapConsumer.ORIGINAL_ORDER = 2;\n\n  SourceMapConsumer.LEAST_UPPER_BOUND = 1;\n  SourceMapConsumer.GREATEST_LOWER_BOUND = 2;\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  SourceMapConsumer.prototype.eachMapping =\n    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n      var mappings;\n      switch (order) {\n      case SourceMapConsumer.GENERATED_ORDER:\n        mappings = this._generatedMappings;\n        break;\n      case SourceMapConsumer.ORIGINAL_ORDER:\n        mappings = this._originalMappings;\n        break;\n      default:\n        throw new Error(\"Unknown order of iteration.\");\n      }\n\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function (mapping) {\n        var source = mapping.source;\n        if (source != null && sourceRoot != null) {\n          source = util.join(sourceRoot, source);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name\n        };\n      }).forEach(aCallback, context);\n    };\n\n  /**\n   * Returns all generated line and column information for the original source\n   * and line provided. The only argument is an object with the following\n   * properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  SourceMapConsumer.prototype.allGeneratedPositionsFor =\n    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: 0\n      };\n\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n\n      var mappings = [];\n\n      var index = this._findMapping(needle,\n                                    this._originalMappings,\n                                    \"originalLine\",\n                                    \"originalColumn\",\n                                    util.compareByOriginalPositions);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line. Since mappings are sorted, this is\n        // guaranteed to find all mappings for the line we are interested in.\n        while (mapping && mapping.originalLine === needle.originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n\n      return mappings;\n    };\n\n  exports.SourceMapConsumer = SourceMapConsumer;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/indexed-source-map-consumer', ['require', 'exports', 'module' ,  'source-map/util', 'source-map/binary-search', 'source-map/source-map-consumer', 'source-map/basic-source-map-consumer'], function(require, exports, module) {\n\n  var util = require('./util');\n  var binarySearch = require('./binary-search');\n  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;\n  var BasicSourceMapConsumer = require('./basic-source-map-consumer').BasicSourceMapConsumer;\n\n  /**\n   * An IndexedSourceMapConsumer instance represents a parsed source map which\n   * we can query for information. It differs from BasicSourceMapConsumer in\n   * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n   * input.\n   *\n   * The only parameter is a raw source map (either as a JSON string, or already\n   * parsed to an object). According to the spec for indexed source maps, they\n   * have the following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - file: Optional. The generated file this source map is associated with.\n   *   - sections: A list of section definitions.\n   *\n   * Each value under the \"sections\" field has two fields:\n   *   - offset: The offset into the original specified at which this section\n   *       begins to apply, defined as an object with a \"line\" and \"column\"\n   *       field.\n   *   - map: A source map definition. This source map could also be indexed,\n   *       but doesn't have to be.\n   *\n   * Instead of the \"map\" field, it's also possible to have a \"url\" field\n   * specifying a URL to retrieve a source map from, but that's currently\n   * unsupported.\n   *\n   * Here's an example source map, taken from the source map spec[0], but\n   * modified to omit a section which uses the \"url\" field.\n   *\n   *  {\n   *    version : 3,\n   *    file: \"app.js\",\n   *    sections: [{\n   *      offset: {line:100, column:10},\n   *      map: {\n   *        version : 3,\n   *        file: \"section.js\",\n   *        sources: [\"foo.js\", \"bar.js\"],\n   *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *        mappings: \"AAAA,E;;ABCDE;\"\n   *      }\n   *    }],\n   *  }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n   */\n  function IndexedSourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sections = util.getArg(sourceMap, 'sections');\n\n    if (version != this._version) {\n      throw new Error('Unsupported version: ' + version);\n    }\n\n    var lastOffset = {\n      line: -1,\n      column: 0\n    };\n    this._sections = sections.map(function (s) {\n      if (s.url) {\n        // The url field will require support for asynchronicity.\n        // See https://github.com/mozilla/source-map/issues/16\n        throw new Error('Support for url field in sections not implemented.');\n      }\n      var offset = util.getArg(s, 'offset');\n      var offsetLine = util.getArg(offset, 'line');\n      var offsetColumn = util.getArg(offset, 'column');\n\n      if (offsetLine < lastOffset.line ||\n          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n        throw new Error('Section offsets must be ordered and non-overlapping.');\n      }\n      lastOffset = offset;\n\n      return {\n        generatedOffset: {\n          // The offset fields are 0-based, but we use 1-based indices when\n          // encoding/decoding from VLQ.\n          generatedLine: offsetLine + 1,\n          generatedColumn: offsetColumn + 1\n        },\n        consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n      }\n    });\n  }\n\n  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  IndexedSourceMapConsumer.prototype._version = 3;\n\n  /**\n   * The list of original sources.\n   */\n  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n    get: function () {\n      var sources = [];\n      for (var i = 0; i < this._sections.length; i++) {\n        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n          sources.push(this._sections[i].consumer.sources[j]);\n        }\n      };\n      return sources;\n    }\n  });\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n  IndexedSourceMapConsumer.prototype.originalPositionFor =\n    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n\n      // Find the section containing the generated position we're trying to map\n      // to an original position.\n      var sectionIndex = binarySearch.search(needle, this._sections,\n        function(needle, section) {\n          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n          if (cmp) {\n            return cmp;\n          }\n\n          return (needle.generatedColumn -\n                  section.generatedOffset.generatedColumn);\n        }, binarySearch.GREATEST_LOWER_BOUND);\n      var section = this._sections[sectionIndex];\n\n      if (!section) {\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      }\n\n      return section.consumer.originalPositionFor({\n        line: needle.generatedLine -\n          (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn -\n          (section.generatedOffset.generatedLine === needle.generatedLine\n           ? section.generatedOffset.generatedColumn - 1\n           : 0)\n      });\n    };\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  IndexedSourceMapConsumer.prototype.sourceContentFor =\n    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n\n        var content = section.consumer.sourceContentFor(aSource, true);\n        if (content) {\n          return content;\n        }\n      }\n      if (nullOnMissing) {\n        return null;\n      }\n      else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n      }\n    };\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  IndexedSourceMapConsumer.prototype.generatedPositionFor =\n    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n\n        // Only consider this section if the requested source is in the list of\n        // sources of the consumer.\n        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n          continue;\n        }\n        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n        if (generatedPosition) {\n          var ret = {\n            line: generatedPosition.line +\n              (section.generatedOffset.generatedLine - 1),\n            column: generatedPosition.column +\n              (section.generatedOffset.generatedLine === generatedPosition.line\n               ? section.generatedOffset.generatedColumn - 1\n               : 0)\n          };\n          return ret;\n        }\n      }\n\n      return {\n        line: null,\n        column: null\n      };\n    };\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  IndexedSourceMapConsumer.prototype._parseMappings =\n    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      this.__generatedMappings = [];\n      this.__originalMappings = [];\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n        var sectionMappings = section.consumer._generatedMappings;\n        for (var j = 0; j < sectionMappings.length; j++) {\n          var mapping = sectionMappings[i];\n\n          var source = mapping.source;\n          var sourceRoot = section.consumer.sourceRoot;\n\n          if (source != null && sourceRoot != null) {\n            source = util.join(sourceRoot, source);\n          }\n\n          // The mappings coming from the consumer for the section have\n          // generated positions relative to the start of the section, so we\n          // need to offset them to be relative to the start of the concatenated\n          // generated file.\n          var adjustedMapping = {\n            source: source,\n            generatedLine: mapping.generatedLine +\n              (section.generatedOffset.generatedLine - 1),\n            generatedColumn: mapping.column +\n              (section.generatedOffset.generatedLine === mapping.generatedLine)\n              ? section.generatedOffset.generatedColumn - 1\n              : 0,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name\n          };\n\n          this.__generatedMappings.push(adjustedMapping);\n          if (typeof adjustedMapping.originalLine === 'number') {\n            this.__originalMappings.push(adjustedMapping);\n          }\n        };\n      };\n\n    this.__generatedMappings.sort(util.compareByGeneratedPositions);\n    this.__originalMappings.sort(util.compareByOriginalPositions);\n  };\n\n  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/binary-search', ['require', 'exports', 'module' , ], function(require, exports, module) {\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   * @param aBias Either 'binarySearch.LEAST_UPPER_BOUND' or\n   *     'binarySearch.GREATEST_LOWER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the element we are\n   *     searching for if the exact element cannot be found.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return mid;\n    }\n    else if (cmp > 0) {\n      // Our needle is greater than aHaystack[mid].\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n      }\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return aHigh < aHaystack.length ? aHigh : -1;\n      } else {\n        return mid;\n      }\n    }\n    else {\n      // Our needle is less than aHaystack[mid].\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n      }\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return mid;\n      } else {\n        return aLow < 0 ? -1 : aLow;\n      }\n    }\n  }\n\n  exports.LEAST_UPPER_BOUND = 1;\n  exports.GREATEST_LOWER_BOUND = 2;\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the index of next highest value checked if there is no exact hit. This is\n   * because mappings between original and generated line/col pairs are single\n   * points, and there is an implicit region between each of them, so a miss\n   * just means that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   * @param aBias Either 'exports.LEAST_UPPER_BOUND' or\n   *     'exports.GREATEST_LOWER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the element we are\n   *     searching for if the exact element cannot be found. Defaults to\n   *     'exports.LEAST_UPPER_BOUND'.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    var aBias = aBias || exports.LEAST_UPPER_BOUND;\n\n    if (aHaystack.length === 0) {\n      return -1;\n    }\n    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias)\n  };\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/basic-source-map-consumer', ['require', 'exports', 'module' ,  'source-map/util', 'source-map/binary-search', 'source-map/array-set', 'source-map/base64-vlq', 'source-map/source-map-consumer'], function(require, exports, module) {\n\n  var util = require('./util');\n  var binarySearch = require('./binary-search');\n  var ArraySet = require('./array-set').ArraySet;\n  var base64VLQ = require('./base64-vlq');\n  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;\n\n  /**\n   * A BasicSourceMapConsumer instance represents a parsed source map which we can\n   * query for information about the original file positions by giving it a file\n   * position in the generated source.\n   *\n   * The only parameter is the raw source map (either as a JSON string, or\n   * already parsed to an object). According to the spec, source maps have the\n   * following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - sources: An array of URLs to the original source files.\n   *   - names: An array of identifiers which can be referrenced by individual mappings.\n   *   - sourceRoot: Optional. The URL root from which all sources are relative.\n   *   - sourcesContent: Optional. An array of contents of the original source files.\n   *   - mappings: A string of base64 VLQs which contain the actual mappings.\n   *   - file: Optional. The generated file this source map is associated with.\n   *\n   * Here is an example source map, taken from the source map spec[0]:\n   *\n   *     {\n   *       version : 3,\n   *       file: \"out.js\",\n   *       sourceRoot : \"\",\n   *       sources: [\"foo.js\", \"bar.js\"],\n   *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *       mappings: \"AA,AB;;ABCDE;\"\n   *     }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n   */\n  function BasicSourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sources = util.getArg(sourceMap, 'sources');\n    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n    var names = util.getArg(sourceMap, 'names', []);\n    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n    var mappings = util.getArg(sourceMap, 'mappings');\n    var file = util.getArg(sourceMap, 'file', null);\n\n    // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n    if (version != this._version) {\n      throw new Error('Unsupported version: ' + version);\n    }\n\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    sources = sources.map(util.normalize);\n\n    // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n    this._names = ArraySet.fromArray(names, true);\n    this._sources = ArraySet.fromArray(sources, true);\n\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this.file = file;\n  }\n\n  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @returns BasicSourceMapConsumer\n   */\n  BasicSourceMapConsumer.fromSourceMap =\n    function SourceMapConsumer_fromSourceMap(aSourceMap) {\n      var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n      smc.sourceRoot = aSourceMap._sourceRoot;\n      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                              smc.sourceRoot);\n      smc.file = aSourceMap._file;\n\n      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();\n      smc.__originalMappings = aSourceMap._mappings.toArray().slice()\n        .sort(util.compareByOriginalPositions);\n\n      return smc;\n    };\n\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n  BasicSourceMapConsumer.prototype._version = 3;\n\n  /**\n   * The list of original sources.\n   */\n  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n    get: function () {\n      return this._sources.toArray().map(function (s) {\n        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n      }, this);\n    }\n  });\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  BasicSourceMapConsumer.prototype._parseMappings =\n    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n      var generatedLine = 1;\n      var previousGeneratedColumn = 0;\n      var previousOriginalLine = 0;\n      var previousOriginalColumn = 0;\n      var previousSource = 0;\n      var previousName = 0;\n      var str = aStr;\n      var temp = {};\n      var mapping;\n\n      while (str.length > 0) {\n        if (str.charAt(0) === ';') {\n          generatedLine++;\n          str = str.slice(1);\n          previousGeneratedColumn = 0;\n        }\n        else if (str.charAt(0) === ',') {\n          str = str.slice(1);\n        }\n        else {\n          mapping = {};\n          mapping.generatedLine = generatedLine;\n\n          // Generated column.\n          base64VLQ.decode(str, temp);\n          mapping.generatedColumn = previousGeneratedColumn + temp.value;\n          previousGeneratedColumn = mapping.generatedColumn;\n          str = temp.rest;\n\n          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n            // Original source.\n            base64VLQ.decode(str, temp);\n            mapping.source = this._sources.at(previousSource + temp.value);\n            previousSource += temp.value;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error('Found a source, but no line and column');\n            }\n\n            // Original line.\n            base64VLQ.decode(str, temp);\n            mapping.originalLine = previousOriginalLine + temp.value;\n            previousOriginalLine = mapping.originalLine;\n            // Lines are stored 0-based\n            mapping.originalLine += 1;\n            str = temp.rest;\n            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n              throw new Error('Found a source and line, but no column');\n            }\n\n            // Original column.\n            base64VLQ.decode(str, temp);\n            mapping.originalColumn = previousOriginalColumn + temp.value;\n            previousOriginalColumn = mapping.originalColumn;\n            str = temp.rest;\n\n            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n              // Original name.\n              base64VLQ.decode(str, temp);\n              mapping.name = this._names.at(previousName + temp.value);\n              previousName += temp.value;\n              str = temp.rest;\n            }\n          }\n\n          this.__generatedMappings.push(mapping);\n          if (typeof mapping.originalLine === 'number') {\n            this.__originalMappings.push(mapping);\n          }\n        }\n      }\n\n      this.__generatedMappings.sort(util.compareByGeneratedPositions);\n      this.__originalMappings.sort(util.compareByOriginalPositions);\n    };\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  BasicSourceMapConsumer.prototype._findMapping =\n    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                           aColumnName, aComparator) {\n      // To return the position we are searching for, we must first find the\n      // mapping for the given position and then return the opposite position it\n      // points to. Because the mappings are sorted, we can use binary search to\n      // find the best mapping.\n\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError('Line must be greater than or equal to 1, got '\n                            + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError('Column must be greater than or equal to 0, got '\n                            + aNeedle[aColumnName]);\n      }\n\n      return binarySearch.search(aNeedle, aMappings, aComparator);\n    };\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  BasicSourceMapConsumer.prototype.computeColumnSpans =\n    function SourceMapConsumer_computeColumnSpans() {\n      for (var index = 0; index < this._generatedMappings.length; ++index) {\n        var mapping = this._generatedMappings[index];\n\n        // Mappings do not contain a field for the last generated columnt. We\n        // can come up with an optimistic estimate, however, by assuming that\n        // mappings are contiguous (i.e. given two consecutive mappings, the\n        // first mapping ends where the second one starts).\n        if (index + 1 < this._generatedMappings.length) {\n          var nextMapping = this._generatedMappings[index + 1];\n\n          if (mapping.generatedLine === nextMapping.generatedLine) {\n            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n            continue;\n          }\n        }\n\n        // The last mapping for each line spans the entire line.\n        mapping.lastGeneratedColumn = Infinity;\n      }\n    };\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n  BasicSourceMapConsumer.prototype.originalPositionFor =\n    function SourceMapConsumer_originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, 'line'),\n        generatedColumn: util.getArg(aArgs, 'column')\n      };\n\n      var index = this._findMapping(needle,\n                                    this._generatedMappings,\n                                    \"generatedLine\",\n                                    \"generatedColumn\",\n                                    util.compareByGeneratedPositions);\n\n      if (index >= 0) {\n        var mapping = this._generatedMappings[index];\n\n        if (mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, 'source', null);\n          if (source != null && this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n          return {\n            source: source,\n            line: util.getArg(mapping, 'originalLine', null),\n            column: util.getArg(mapping, 'originalColumn', null),\n            name: util.getArg(mapping, 'name', null)\n          };\n        }\n      }\n\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    };\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * availible.\n   */\n  BasicSourceMapConsumer.prototype.sourceContentFor =\n    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n\n      if (this.sourceRoot != null) {\n        aSource = util.relative(this.sourceRoot, aSource);\n      }\n\n      if (this._sources.has(aSource)) {\n        return this.sourcesContent[this._sources.indexOf(aSource)];\n      }\n\n      var url;\n      if (this.sourceRoot != null\n          && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\"\n            && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n        }\n\n        if ((!url.path || url.path == \"/\")\n            && this._sources.has(\"/\" + aSource)) {\n          return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n        }\n      }\n\n      // This function is used recursively from\n      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n      // don't want to throw if we can't find the source - we just want to\n      // return null, so we provide a flag to exit gracefully.\n      if (nullOnMissing) {\n        return null;\n      }\n      else {\n        throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n      }\n    };\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n  BasicSourceMapConsumer.prototype.generatedPositionFor =\n    function SourceMapConsumer_generatedPositionFor(aArgs) {\n      var needle = {\n        source: util.getArg(aArgs, 'source'),\n        originalLine: util.getArg(aArgs, 'line'),\n        originalColumn: util.getArg(aArgs, 'column')\n      };\n\n      if (this.sourceRoot != null) {\n        needle.source = util.relative(this.sourceRoot, needle.source);\n      }\n\n      var index = this._findMapping(needle,\n                                    this._originalMappings,\n                                    \"originalLine\",\n                                    \"originalColumn\",\n                                    util.compareByOriginalPositions);\n\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    };\n\n  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\ndefine('source-map/source-node', ['require', 'exports', 'module' ,  'source-map/source-map-generator', 'source-map/util'], function(require, exports, module) {\n\n  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n  var util = require('./util');\n\n  // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n  // operating systems these days (capturing the result).\n  var REGEX_NEWLINE = /(\\r?\\n)/;\n\n  // Newline character code for charCodeAt() comparisons\n  var NEWLINE_CODE = 10;\n\n  // Private symbol for identifying `SourceNode`s when multiple versions of\n  // the source-map library are loaded. This MUST NOT CHANGE across\n  // versions!\n  var isSourceNode = \"$$$isSourceNode$$$\";\n\n  /**\n   * SourceNodes provide a way to abstract over interpolating/concatenating\n   * snippets of generated JavaScript source code while maintaining the line and\n   * column information associated with the original source code.\n   *\n   * @param aLine The original line number.\n   * @param aColumn The original column number.\n   * @param aSource The original source's filename.\n   * @param aChunks Optional. An array of strings which are snippets of\n   *        generated JS, or other SourceNodes.\n   * @param aName The original identifier.\n   */\n  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  SourceNode.fromStringWithSourceMap =\n    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n      // The SourceNode we want to fill with the generated code\n      // and the SourceMap\n      var node = new SourceNode();\n\n      // All even indices of this array are one line of the generated code,\n      // while all odd indices are the newlines between two adjacent lines\n      // (since `REGEX_NEWLINE` captures its match).\n      // Processed fragments are removed from this array, by calling `shiftNextLine`.\n      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n      var shiftNextLine = function() {\n        var lineContents = remainingLines.shift();\n        // The last line of a file might not have a newline.\n        var newLine = remainingLines.shift() || \"\";\n        return lineContents + newLine;\n      };\n\n      // We need to remember the position of \"remainingLines\"\n      var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n      // The generate SourceNodes we need a code range.\n      // To extract it current and last mapping is used.\n      // Here we store the last mapping.\n      var lastMapping = null;\n\n      aSourceMapConsumer.eachMapping(function (mapping) {\n        if (lastMapping !== null) {\n          // We add the code from \"lastMapping\" to \"mapping\":\n          // First check if there is a new line in between.\n          if (lastGeneratedLine < mapping.generatedLine) {\n            var code = \"\";\n            // Associate first line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n            lastGeneratedLine++;\n            lastGeneratedColumn = 0;\n            // The remaining code is added without mapping\n          } else {\n            // There is no new line in between.\n            // Associate the code between \"lastGeneratedColumn\" and\n            // \"mapping.generatedColumn\" with \"lastMapping\"\n            var nextLine = remainingLines[0];\n            var code = nextLine.substr(0, mapping.generatedColumn -\n                                          lastGeneratedColumn);\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                                lastGeneratedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n            addMappingWithCode(lastMapping, code);\n            // No more remaining code, continue\n            lastMapping = mapping;\n            return;\n          }\n        }\n        // We add the generated code until the first mapping\n        // to the SourceNode without any mapping.\n        // Each line is added as separate string.\n        while (lastGeneratedLine < mapping.generatedLine) {\n          node.add(shiftNextLine());\n          lastGeneratedLine++;\n        }\n        if (lastGeneratedColumn < mapping.generatedColumn) {\n          var nextLine = remainingLines[0];\n          node.add(nextLine.substr(0, mapping.generatedColumn));\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n        }\n        lastMapping = mapping;\n      }, this);\n      // We have processed all mappings.\n      if (remainingLines.length > 0) {\n        if (lastMapping) {\n          // Associate the remaining code in the current line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n        }\n        // and add the remaining lines without any mapping\n        node.add(remainingLines.join(\"\"));\n      }\n\n      // Copy sourcesContent into SourceNode\n      aSourceMapConsumer.sources.forEach(function (sourceFile) {\n        var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n        if (content != null) {\n          if (aRelativePath != null) {\n            sourceFile = util.join(aRelativePath, sourceFile);\n          }\n          node.setSourceContent(sourceFile, content);\n        }\n      });\n\n      return node;\n\n      function addMappingWithCode(mapping, code) {\n        if (mapping === null || mapping.source === undefined) {\n          node.add(code);\n        } else {\n          var source = aRelativePath\n            ? util.join(aRelativePath, mapping.source)\n            : mapping.source;\n          node.add(new SourceNode(mapping.originalLine,\n                                  mapping.originalColumn,\n                                  source,\n                                  code,\n                                  mapping.name));\n        }\n      }\n    };\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.add = function SourceNode_add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (var i = aChunk.length-1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    }\n    else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    }\n    else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  };\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n    var chunk;\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      }\n      else {\n        if (chunk !== '') {\n          aFn(chunk, { source: this.source,\n                       line: this.line,\n                       column: this.column,\n                       name: this.name });\n        }\n      }\n    }\n  };\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  SourceNode.prototype.join = function SourceNode_join(aSep) {\n    var newChildren;\n    var i;\n    var len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len-1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  };\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n    var lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    }\n    else if (typeof lastChild === 'string') {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    }\n    else {\n      this.children.push(''.replace(aPattern, aReplacement));\n    }\n    return this;\n  };\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  SourceNode.prototype.setSourceContent =\n    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n    };\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  SourceNode.prototype.walkSourceContents =\n    function SourceNode_walkSourceContents(aFn) {\n      for (var i = 0, len = this.children.length; i < len; i++) {\n        if (this.children[i][isSourceNode]) {\n          this.children[i].walkSourceContents(aFn);\n        }\n      }\n\n      var sources = Object.keys(this.sourceContents);\n      for (var i = 0, len = sources.length; i < len; i++) {\n        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n      }\n    };\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  SourceNode.prototype.toString = function SourceNode_toString() {\n    var str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  };\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n    var generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    var map = new SourceMapGenerator(aArgs);\n    var sourceMappingActive = false;\n    var lastOriginalSource = null;\n    var lastOriginalLine = null;\n    var lastOriginalColumn = null;\n    var lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if(lastOriginalSource !== original.source\n           || lastOriginalLine !== original.line\n           || lastOriginalColumn !== original.column\n           || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (var idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map: map };\n  };\n\n  exports.SourceNode = SourceNode;\n\n});\n/* -*- Mode: js; js-indent-level: 2; -*- */\n///////////////////////////////////////////////////////////////////////////////\n\nthis.sourceMap = {\n  SourceMapConsumer: require('source-map/source-map-consumer').SourceMapConsumer,\n  SourceMapGenerator: require('source-map/source-map-generator').SourceMapGenerator,\n  SourceNode: require('source-map/source-node').SourceNode\n};\n"],"sourceRoot":"/src/assets/js/"}